---
description: Build checklist for implementing Redis caching with ElastiCache for the REST API
globs: ["/lambda/**/*.py", "/infrastructure/terraform/**/*.tf"]
alwaysApply: false
---

# üß± Cached Table Stack: ElastiCache (Redis) for Context + Page Facts

## Goal
Build Redis-cached versions of the `User` and `Pages` tables to serve low-latency context and facts to the Recursive Learning Lambda REST API. This supports pydia-style reference and chat continuity across threads.

---

## üß† Key Concepts

- **Redis** ‚Äì A super-fast, in-memory key-value store. Think of it as a shared scratchpad for quick lookups, like "Who is this user?" or "What facts belong to this page?"
- **TTL (Time To Live)** ‚Äì Each record in Redis expires after a set time, like milk in the fridge. This keeps the cache fresh without manual cleanup.
- **Rehydration** ‚Äì If Redis doesn't have the data (a cache miss), the system falls back to Airtable, fetches the data, and puts it back in Redis for future calls.
- **Cache key** ‚Äì A unique label like `user:abc123`. This is how Redis knows which data to return.
- **ElastiCache** ‚Äì AWS's managed Redis service. It handles scaling, networking, and uptime for you.

---

## ‚úÖ Setup Redis (ElastiCache)

- [ ] Create Redis cluster in ElastiCache via AWS Console or Terraform
- [ ] Configure subnet group for VPC Lambda access (not publicly exposed)
- [ ] Store host, port, and (if applicable) auth token in AWS SSM Parameter Store
- [ ] Tag Redis with `Project=RecursiveLearning`, `Stack=Cache`, `Env=Dev/Prod`

---

## ‚úÖ Define Cache Schema

- [ ] Define key structure:
  - `user:{id}` for user records
  - `page:{id}` for page metadata and facts
- [ ] Define TTLs:
  - Pages ‚Üí `3600` sec (1 hr)
  - Users ‚Üí `21600` sec (6 hr)
- [ ] Format values as JSON from Airtable response

---

## ‚úÖ Write Airtable ‚Üí Redis Sync Lambda

- [ ] Create `make:build:cache-stack` scenario or Lambda function
- [ ] Pull `User` and `Pages` data from Airtable
- [ ] Format each record to match key schema
- [ ] Upsert into Redis using `SET key value EX ttl`
- [ ] Log sync stats: count created, updated, failed

---

## ‚úÖ Integrate into rl-restapi-lambda

- [ ] Add `redisClient` to `lambda_utils`, using SSM param
- [ ] Add Redis-first fetch logic to context and page loaders
  - Check Redis: `GET user:{id}` and `GET page:{id}`
  - If miss, fetch from Airtable and `SET` back to Redis
- [ ] Log cache hits and misses

---

## ‚úÖ End-to-End Testing

- [ ] Simulate Lambda call with known user/page ID in Redis
- [ ] Validate Redis response speed and data structure
- [ ] Validate fallback ‚Üí Airtable ‚Üí Redis rehydration
- [ ] Set short TTL (e.g. 5s) to verify expiry behavior

---

## üß™ Unit Test Cases

- [ ] `getUserFromCache(id)` returns structured JSON or null
- [ ] `getPageContext(id)` pulls from Redis or rehydrates
- [ ] `syncUsersToCache()` upserts Redis keys with correct TTL
- [ ] TTL expires and data is refreshed on next call

---

## üõ† Infra Notes

- [ ] Use non-free tier (at least 1GB) to avoid eviction
- [ ] Add Redis CloudWatch alarms: memory, connections, eviction
- [ ] Use `dev:` or `prod:` prefixes on keys if Redis is shared

---

## ‚è≠Ô∏è Next Up (Post MVP)

- [ ] Add `Topics`, `Snippets`, `PageSections` to cache
- [ ] Explore RedisJSON or hash storage for sub-record updates
- [ ] Consider hybrid caching: Redis + in-memory (per function) 