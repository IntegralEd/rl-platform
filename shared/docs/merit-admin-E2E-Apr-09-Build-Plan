# Merit Redis Integration Checklist (2025.04.09)

## Critical Rules & Restrictions
- ⚠️ DO NOT edit `merit_live.html` or `merit_temp.html` without explicit authorization
- ✅ Focus automation and enhancements on `/clients/elpl/merit/merit.html`
- ✅ All changes must follow Redis caching implementation standards
- ✅ Maintain existing client-facing functionality during integration

## Integration Priorities

### 1. Redis Setup & Verification
- [ ] Confirm Redis server operational status
- [ ] Verify SSM parameter `/integraled/redis/endpoint` accessibility
- [ ] Test Lambda function permissions for Redis access
- [ ] Validate frontend API endpoint configuration

### 2. Primary Resource Integration (`merit.html`)
- [ ] Update API endpoints to use Redis-backed system
- [ ] Implement OpenAI assistant integration
- [ ] Add Redis cache headers and retry mechanisms
- [ ] Configure thread persistence with Redis

### 3. Chat System Enhancement
- [ ] Implement Redis-based message caching
- [ ] Add loading states for cache operations
- [ ] Configure cache invalidation triggers
- [ ] Add cache status indicators for debugging

### 4. Performance Optimization
- [ ] Implement optimistic UI updates
- [ ] Add cache write-through mechanisms
- [ ] Configure proper cache TTL settings
- [ ] Add performance monitoring

## Testing Requirements

### Initial Testing
- [ ] Redis connectivity verification
- [ ] Basic chat functionality
- [ ] Message persistence
- [ ] Cache hit/miss handling

### End Testing
- [ ] Full chat system responsiveness
- [ ] Redis cache performance
- [ ] Concurrent user support
- [ ] System load validation

### Performance Metrics
- [ ] Message load time < 100ms
- [ ] Cache hit ratio > 80%
- [ ] Response time < 300ms
- [ ] Concurrent user capacity

## Integration Notes
- Use existing CURL tests as reference for OpenAI integration
- Maintain backward compatibility
- Document all cache-related configurations
- Monitor system performance during integration

## Rollback Plan
- Maintain current production endpoints
- Document all changes for potential rollback
- Keep existing functionality intact
- Test rollback procedures

## Next Steps
1. Begin Redis server verification
2. Update API integration in `merit.html`
3. Implement chat system enhancements
4. Conduct thorough testing
5. Document all changes and configurations

## Redis Access Configuration

### Backend Access (Verified)
- [x] Endpoint: `rl-platform-cache-2wqhx1.serverless.use2.cache.amazonaws.com:6379`
- [x] User ARN: `arn:aws:elasticache:us-east-2:559050208320:user:recursive-backend`
- [x] User credentials in SSM
- [ ] Lambda functions configured with VPC access
- [ ] Security group rules verified

### Frontend Access (To Be Implemented)
- [ ] Create frontend-specific Redis user
- [ ] Store credentials in SSM
- [ ] Configure API Gateway endpoints
- [ ] Implement frontend Redis client
- [ ] Add connection pooling
- [ ] Implement retry logic

### Access Patterns
```javascript
// Backend (Lambda) Access
const redis = new Redis({
  host: process.env.REDIS_ENDPOINT,
  port: 6379,
  username: 'recursive-backend',
  password: process.env.REDIS_PASSWORD,
  tls: {}
});

// Frontend (API) Access
const cache = {
  async get(key) {
    const response = await fetch('/api/v1/cache/' + key, {
      headers: {
        'X-API-Key': process.env.API_KEY
      }
    });
    return response.json();
  },
  
  async set(key, value, ttl = 3600) {
    await fetch('/api/v1/cache', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'X-API-Key': process.env.API_KEY
      },
      body: JSON.stringify({ key, value, ttl })
    });
  }
};
```

### Security Requirements
- [ ] All Redis access through API Gateway
- [ ] Rate limiting implemented
- [ ] Request validation
- [ ] Error handling
- [ ] Monitoring and alerts 

# Merit Admin E2E Build Plan - April 9 Update

## Critical Layout Issues (Priority Fix)

### 1. Admin Header Implementation
- [ ] Add fixed 50px admin header across all admin pages
- [ ] Implement consistent branding with Recursive Learning logo
- [ ] Add user info display (Admin: Name)
- [ ] Add version info display (Version YYYY.MM.DD.HH:MMam/pm)

### 2. Left Navigation Panel Fixes
- [ ] Convert to card-based vertical navigation (260-300px width)
- [ ] Implement proper spacing between nav cards
- [ ] Add gem icons for feature indicators
- [ ] Structure navigation hierarchy:
  ```html
  <div class="nav-card">
    <strong>Goalsetter</strong>
    <!-- Gem indicator -->
    <div class="feature-list">
      <!-- Features -->
    </div>
  </div>
  ```

### 3. Feature Tabs Implementation
- [ ] Add gem-based tab navigation
- [ ] Implement proper tab headers:
  - Toggle
  - Iframe
  - Comments
  - Change Orders
  - LRS
  - Status
- [ ] Add tab content areas with proper grid layout
- [ ] Ensure tab state persistence

### 4. Grid Layout Restoration
- [ ] Implement two-column grid structure:
  ```css
  .admin-layout {
    display: grid;
    grid-template-columns: 260px 1fr;
    gap: 16px;
    padding: 24px;
  }
  ```
- [ ] Fix content overlap issues
- [ ] Ensure proper spacing between components

### 5. Module Organization
- [ ] Separate system-level controls (version, tokens) into Quick Actions section
- [ ] Move chat configuration to proper admin module
- [ ] Implement proper hierarchy for admin controls

## Implementation Steps

1. **Base Layout Structure**
```html
<header class="admin-header">
  <!-- 50px header content -->
</header>

<div class="admin-layout">
  <div class="nav-panel">
    <!-- Card-based navigation -->
  </div>
  <div class="content-panel">
    <!-- Tab system -->
  </div>
</div>
```

2. **Navigation Cards**
```html
<div class="nav-card">
  <div class="card-header">
    <strong>Module Name</strong>
    <span class="gem-indicator"></span>
  </div>
  <div class="feature-list">
    <a class="feature-item">Feature 1</a>
    <a class="feature-item">Feature 2</a>
  </div>
</div>
```

3. **Tab System**
```html
<div class="tab-container">
  <div class="tab-header">
    <button class="tab active">
      <span class="gem"></span>
      <span class="label">Toggle</span>
    </button>
    <!-- More tabs -->
  </div>
  <div class="tab-content">
    <!-- Content for active tab -->
  </div>
</div>
```

## CSS Requirements

1. **Core Layout**
```css
:root {
  --header-height: 50px;
  --nav-width: 260px;
  --primary-color: #004080;
  --secondary-color: #0060A0;
}

.admin-layout {
  display: grid;
  grid-template-columns: var(--nav-width) 1fr;
  min-height: calc(100vh - var(--header-height));
}
```

2. **Navigation Cards**
```css
.nav-card {
  background: white;
  border-radius: 8px;
  box-shadow: 0 1px 3px rgba(0,0,0,0.1);
  margin-bottom: 16px;
}
```

3. **Gem Styling**
```css
.gem-indicator {
  width: 12px;
  height: 12px;
  border-radius: 50%;
  background: var(--primary-color);
}
```

## Validation Checklist

- [ ] Header maintains 50px height across all pages
- [ ] Navigation cards properly contain their content
- [ ] Gems correctly indicate active states
- [ ] Tab system properly manages content switching
- [ ] Grid layout maintains proper spacing
- [ ] No content overflow or overlap issues
- [ ] Proper module hierarchy maintained
- [ ] Consistent styling across all admin pages

## Dependencies

1. CSS Files:
   - `/admin/assets/css/admin.css`
   - `/shared/assets/css/variables.css`

2. JavaScript Files:
   - `/admin/assets/js/admin.js`
   - `/admin/assets/js/admin-nav.js`
   - `/admin/assets/js/admin-common.js`

## Testing Requirements

1. Layout Integrity:
   - Verify grid structure maintains alignment
   - Check responsive behavior
   - Test tab switching
   - Validate gem state management

2. Navigation:
   - Test card expansion/collapse
   - Verify feature list visibility
   - Check gem indicator states

3. Content Management:
   - Verify tab content loading
   - Test module interactions
   - Validate state persistence

## Next Steps

1. Implement base layout structure
2. Add navigation card system
3. Implement gem-based tabs
4. Add content management
5. Style and polish
6. Test and validate
7. Document changes 